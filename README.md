# struct Ring

Структура ***"Кольцо"*** - шаблонный контейнер, подобие списка, концы которого "связаны" между собой.

<!-- Предпосылки реализации -->
## Предпосылки реализации (можно пропустить):
Шла любительская работа над реализацией генератора QR-кода по статье на Хабре (url: https://habr.com/ru/articles/172525/). На некотором шаге данные разбиваются на определенное количество блоков. Данные блоки было решено хранить в векторе векторов (```vector<vector<byte>>```) - контейнер блоков. Задача решалась "в лоб", глубоко в процесс оптимизиции я не погружался, потому причины такой реализации были следующие: 
    
1. В пункте **"Создание байтов коррекции"** описан собственно алгоритм создания байтов коррекции. Для создания очередного длока байтов коррекции необходимо копировать соответсвующий блок информации в отдельный переменный блок. Было бы удобно сделать примерно следующее простое копирование:

    ```copy(block[i].begin(), block[i].end(), tmp_block.begin());```

Конечно там чуть сложнее, но не об этом речь.

2. В пункте **"Объединение блоков"** блоки информации и блоки байтов коррекции по определенным правилами объединяются. Вектор векторов практически играет роль матрицы (последние вектора (блоки) могут иметь размер на **1** больше). "Будет простое обращение по двум индексам" - решил я. 

Пункт **"Объединение блоков"** остался без вопросов. Но не пункт **"Создание байтов коррекции"**. 

Если его внимательно прочитать, то можно заметить, что на каждом шаге один элемент из переменного блока удаляется, элементы смещаются влево на один, но при этом размер блока не меняется. 

+ Смещать поочередно элементы вектора ? - некрасиво, по моему.
+ ```erase[tmp_block.begin()]``` ? - уменьшается размер блока, так устроен erase. 
+ Не смещать и церемониться со "сдвигами" при помощи переменных-помощников ? - возможно, но в этот раз было лень ломать голову.

По данным соображениям было решено создать структуру данных ***"Кольцо"***.

<!-- Составляющие -->
## Составляющие кольца

Кольцо состоит из элементов типа ```Ring<T>::Element```, каждый из которых содержит:
+ ```T value```       - значение;
+ ```Element* last``` - указатель на предыдущий элемент;
+ ```Element* next``` - указатель на следующий элемент.

Первого или последнего элемента так таковых нет - элементы объеденены в кольцо. Но есть понятие *"текущего элемента"*. За текущий элемент отвечает указатель ```Element* current```. 

В случае, когда размер кольца равен 0 - ```current = nullptr```.
В случае, когда размер кольца равен 1 - ```current->next = current->last = current```.

<!-- Методы -->
## Методы
Для лучшего понимания принципа работы представьте, что *"кольцо"* - настенные часы, а *"текущий элемент"* - указатель на место 12-го часа (указатель на любое значение вверху, на 12 часов). И пусть кольцо будет полным, как часы: от 1 до 12. Текущий элемент 12.

### Вращения

1. ```void spinF(size_t step = 1)``` - вращение кольца вперед, против часовой стрелки

    **Действие:** прокрутка кольца против часовой стрелки на ```step``` элементов.

    **Объяснение:** представьте, что вы взяли часы и начинаете прокручивать их против часовой стрелки. При данном действии текущий элемент изменяется по часовой стрелке:
    
    ```1, 2, 3, 4 .... ```

    Поэтому метод называется "вращение вперед".

2. ```void spinB(size_t step = 1)``` - вращение кольца назад, по часовой стрелке

    **Действие:** прокрутка кольца по часовой стрелке  на ```step``` элементов.

    **Объяснение:** аналогично ```spinF()```, но с впращением часов по часовой стрелке. При данном действии текущий элемент изменяется против часовой стрелки:
    
    ```11, 10, 9, 8 .... ```

3. ```void spin(int step = 1)``` - вращение кольца

    **Действие:** прокрутка кольца на ```step``` элементов. При отрицательном значении ```step``` вызывается ```spinB()```, при положительном - ```spinF()```.

### Вставка, удаление, обращение к текущему элементу
Алгоритмы вставки реализованы таким образом, что при вставке нового элемента, текущий элемент не меняется на него, а **остается прежним**.

1. ```void pushB(const T& value)``` - вставка элемента назад, слева от текущего

    **Действие:** добавляет новый элемент слева от текущего.

    **Объяснение:** если представить кольцо массивом, то выглядит добавление назад, как добавление в конец:
        
    ```
    array [0, 1, 2, 3, 4, 5]
    ring []
     
    1. ring [0]
    2. ring [0, 1]
    3. ring [0, 1, 2]
    ...
    6. ring [0, 1, 2, 3, 4, 5]
    ```

    Таким образом массив ```array``` записан в кольце по цасовой стрелке.

2. ```void pushF(const T& value)``` - вставла элемента вперед, справа от текущего

    **Действие:** добавляет новый элемент справа от текущего.

    **Объяснение:** если представить кольцо массивом, то выглядит добавление назад, как добавление на позицию с индексом 1:

    ```
    array [0, 1, 2, 3, 4, 5]
    ring []

    1. ring [0]
    2. ring [0, 1]
    3. ring [0, 2, 1]
    ...
    6. ring [0, 5, 4, 3, 2, 1]
    ```

    Если применить вращение с шагом 1 вперед к полученному кольцу, то получим следующее представление:

    ```7. ring [5, 4, 3, 2, 1, 0]```

    Таким образом массив ```array``` записан в кольце против часовой стрелки.

3. ```void pop()``` - удаление текущего элемента

    **Действие:** удаление текущего элемента с переходом к следующему, стоящему справа от текущего. 

    Примечание: возможно стоило реализовать 2 удаления подобно вставкам: 

    + ```popB()``` - удаление текущего с переходом к предыдущему;
    + ```popF()``` - удаление текущего с переходом к следующему;

    но мне показалось это излишним. 

    В случае необходимости можно просто переименовать данный метод ```pop() -> popF()```, скопировать его, чуть править и получить вдобавок метод ```popB()```.


4. ```T& top()``` - обращение к текущему элементу кольца

    **Действие:** возвращает прямую ссылку к значению элемента. Это дает возможность как использования значения в текущем элементе, так и его изменения.

    Примечание: в случае пустого кольца выбрасывает исключение ```throw "Segmentation fault. Dinamic ring is empty"```.

### Иные методы
Иные методы включают в себя:

+ ```size_t size()```  - получение размера кольца;
+ ```bool isEmpty()``` - проверка на пустоту;
+ ```void clear()```   - очистка кольца.

Стоит отметить, что если кольцо содержит элементы-указатели, метод ```clear()``` **не высвобождает их память**.*




## Заключение
В дальнейшем планируется оснастить кольцо константными итераторами ```cbegin(), cend(), crbegin(), crend()```, а также пересмотреть некоторые методы и при возможности сделать их константными. 

Если имеются предложения или замечания - пишите на почту *AndreyPisarenko66@yandex.ru* или *ap.bmx123@gmail.com*, буду рад обратной связи и новым взглядам)